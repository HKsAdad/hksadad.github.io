/* esm.sh - github:rahatool/s2-geometry#23573d9 */
var p=function(t){let n=function(l){let r=[Math.abs(l[0]),Math.abs(l[1]),Math.abs(l[2])];return r[0]>r[1]?r[0]>r[2]?0:2:r[1]>r[2]?1:2},e=function(l,r){switch(l){case 0:return[r[1]/r[0],r[2]/r[0]];case 1:return[-r[0]/r[1],r[2]/r[1]];case 2:return[-r[0]/r[2],-r[1]/r[2]];case 3:return[r[2]/r[0],r[1]/r[0]];case 4:return[r[2]/r[1],-r[0]/r[1]];case 5:return[-r[1]/r[2],-r[0]/r[2]];default:throw Error("Invalid face")}},i=n(t);t[i]<0&&(i+=3);let a=e(i,t);return[i,a]},I=function(t,n){let e=n[0],i=n[1];switch(t){case 0:return[1,e,i];case 1:return[-e,1,i];case 2:return[-e,-i,1];case 3:return[-1,-i,-e];case 4:return[i,-1,-e];case 5:return[i,e,-1];default:throw Error("Invalid face")}},M=function(t){let n=function(e){return e>=.5?.3333333333333333*(4*e*e-1):.3333333333333333*(1-4*(1-e)*(1-e))};return[n(t[0]),n(t[1])]},b=function(t){let n=function(e){return e>=0?.5*Math.sqrt(1+3*e):1-.5*Math.sqrt(1-3*e)};return[n(t[0]),n(t[1])]},d=function(t,n){let e=1<<n,i=function(a){let l=Math.floor(a*e);return Math.max(0,Math.min(e-1,l))};return[i(t[0]),i(t[1])]},L=function(t,n,e){let i=1<<n;return[(t[0]+e[0])/i,(t[1]+e[1])/i]},T=class{constructor(){this.lat=0,this.lng=0}static from(t,n,e=!0){e&&(t=Math.max(Math.min(t,90),-90),n=(n+180)%360+(n<-180||n==180?180:-180));let i=new this;return i.lat=t,i.lng=n,i}static fromInteger(t){return u.fromInteger(t).toLatLng()}static _fromXYZ(t){let n=180/Math.PI,e=Math.atan2(t[2],Math.sqrt(t[0]*t[0]+t[1]*t[1])),i=Math.atan2(t[1],t[0]);return this.from(e*n,i*n)}_toXYZ(){let t=Math.PI/180,n=this.lat*t,e=this.lng*t,i=Math.cos(n);return[Math.cos(e)*i,Math.sin(e)*i,Math.sin(n)]}toInteger(t){return u.fromLatLng(this,t).toInteger()}getNeighbors(t){return u.fromLatLng(this,t).getNeighbors()}compareTo(t){return this.toInteger()-t.toInteger()}},_=class{constructor(){this.x=0,this.y=0}flip(){let t=this.x;this.x=this.y,this.y=t}},c=30,u=class{constructor(){this.face=0,this.ij=[0,0],this.level=c}static from(t,n,e=c){e=Math.min(Math.max(e,1),c);let i=new this;return i.face=t,i.ij=n,i.level=e,i}static fromLatLng(t,n=c){let e=t._toXYZ(),i=p(e),a=b(i[1]),l=d(a,n);return this.from(i[0],l,n)}static fromInteger(t){t=BigInt(t);let n=function(r,s,f,o){o==0&&(f==1&&(s.x=r-1-s.x,s.y=r-1-s.y),s.flip())},e=t>>61n,i=BigInt.asUintN(61,t),a=c,l=new _;for(;(i&1n)==0n;)i>>=2n,a-=1;i>>=1n;for(let r=0;r<a;r+=1){let s=i&3n,f=0,o=0;s==1n?o=1:s==2n?(f=1,o=1):s==3n&&(f=1);let h=Math.pow(2,r);n(h,l,f,o),l.x+=h*f,l.y+=h*o,i>>=2n}return e%2n==1&&l.flip(),this.from(Number(e),[l.x,l.y],a)}toLatLng(){let t=L(this.ij,this.level,[.5,.5]),n=M(t),e=I(this.face,n);return T._fromXYZ(e)}*getCornerLatLngs(){let t=[[0,0],[0,1],[1,1],[1,0]];for(let n of t){let e=L(this.ij,this.level,n),i=M(e),a=I(this.face,i);yield T._fromXYZ(a)}}static _pointToHilbertQuadList(t,n=c,e=0){let i={a:[[0n,"d"],[1n,"a"],[3n,"b"],[2n,"a"]],b:[[2n,"b"],[1n,"b"],[3n,"a"],[0n,"c"]],c:[[2n,"c"],[3n,"d"],[1n,"c"],[0n,"b"]],d:[[0n,"a"],[3n,"c"],[1n,"d"],[2n,"d"]]},a=e%2?"d":"a",l=0n,r=64n,[s,f]=t;for(let o=n-1;o>=0;o-=1){let h=1<<o,m=s&h?1:0,g=f&h?1:0,[S,v]=i[a][m*2+g];a=v,r-=2n,l|=S<<r}return l}toInteger(t=0){let n=u._pointToHilbertQuadList(this.ij,this.level,this.face);if(t){let e=BigInt(64-this.level*2);n=(n>>e)+BigInt(t)<<e}return BigInt(this.face)<<61n|n>>3n|1n<<BigInt(60-this.level*2)}*getNeighbors(){let t=function(l,r,s){let f=1<<s;if(r[0]>=0&&r[1]>=0&&r[0]<f&&r[1]<f)return u.from(l,r,s);{let o=L(r,s,[.5,.5]),h=M(o),m=I(l,h),g=p(m);return l=g[0],h=g[1],o=b(h),r=d(o,s),u.from(l,r,s)}},{face:n,ij:[e,i],level:a}=this.face;yield t(n,[e-1,i],a),yield t(n,[e,i-1],a),yield t(n,[e+1,i],a),yield t(n,[e,i+1],a)}move(t){return u.fromInteger(this.toInteger(t))}includes(t){t instanceof T&&(t=u.fromLatLng(t));let n=BigInt(61-this.level*2);return this.toInteger()>>n==t.toInteger()>>n}compareTo(t){return this.toInteger()-t.toInteger()}};export{u as S2Cell,T as S2LatLng};
//# sourceMappingURL=s2-geometry.mjs.map